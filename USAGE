TABLE OF CONTENTS
=================

I.  BETSY Quick Reference
II.  BETSY Tutorial
III.  BETSY Cookbook
IV.  Managing Cache



Please email if there are any problems with this document.

Thanks,
Jeff
jeffrey.t.chang@uth.tmc.edu



I.  BETSY QUICK REFERENCE
=========================

betsy_run.py -h    Show a help message with description of arguments.
betsy_run.py       Browse the knowledge base.

Some useful flags:
  --num_cores <int>         Set the maximum number of cores to use.
  --receipt <filename>      Save a record of the analysis run (as a text file).
  --network_png <filename>  Save the graph with pipelines as a PNG file.


BETSY is concurrency safe.  You can run multiple instances
simultaneously.  If two instances are operating on the same data, they
won't do the same calculations, and they won't overwrite each other's
results in the cache.  (They may overwrite files specified by the
user, e.g. in --network_png).




II.  BETSY TUTORIAL
===================

The main interface to the BETSY expert system is through the
betsy_run.py script.  In this system, you specify the desired output
(e.g. a gene expression data set), and work with BETSY to refine the
pipeline until you come upon one that fits your needs.  Here is an
example interaction with the system to generate a clustered heatmap of
a gene expression data set.

1.  First, query the BETSY knowledge base for the DataTypes that can
be produced.

$ betsy_run.py

In the output, I see that the DataType for generating a heatmap is
called a "Heatmap".


2.  Ask BETSY to create a network that produces a Heatmap.  I do this
by specifying an "--output" parameter.

$ betsy_run.py --network_png graph.png --output Heatmap
# Will run for a minute or two.

This will show (in the terminal) all the possible combination of
"inputs" that can be used to generate a Heatmap.  As you can see,
there are many possibilities.

The "--network_png" argument tells BETSY to create a file "graph.png"
in the local directory that shows the graph of the pipelines that can
create a Heatmap.

Zooming in, we can see that there are light and dark grey nodes.  The
light ones indicate Data objects, and the dark ones are Modules that
can convert one type of Data to another.  They are connected by
arrows, that indicate which Data are inputs and outputs to each
module.  On the bottom of the graph is a Heatmap object.  BETSY can
take as input any one (or combination) of Data objects as inputs to
create a Heatmap.

To get a description of what these Data and Module nodes are, we can
examine the BETSY knowledge base:
$ betsy_run.py


3.  We would like to use a gene expression file that is currently
stored in the GEO database.  Therefore, we will refine the pipeline by
telling BETSY that we would like to use a "GEOSeries" (seen in the
results from the terminal in the previous step).

$ betsy_run.py --network_png graph.png \
    --input GEOSeries \
    --output Heatmap

This tells BETSY that we would like to generate a Heatmap from a
GEOSeries.  Know that it knows the desired input, the graph will show
the pipeline(s) that run from the input(s) to the output.

The order of the arguments to betsy_run.py can be important.
"--input" goes before "--output".



4.  Reading through the messages that BETSY printed to the terminal,
we see lines:
    Missing --mattr: download_GEO_family_soft requires attribute "GSEID".
    Missing --mattr: download_geo_seriesmatrix requires attribute "GSEID".
    Missing --mattr: download_geo_supplement requires attribute "GSEID".

This means that these modules require an attribute "GSEID" to run.  In
this case, it is asking for the identifier of the GEO record to
download.

"--mattr" stands for (m)odule (attr)ibute, which is a parameter that
changes how a module runs.  Some of the attributes are required
(e.g. here, we can't download data from GEO without knowing which data
to download), and sometimes attributes are optional.  They are not
required to run, but may change the module's behavior (e.g. when we
generate the heatmap, there are attributes to specify the color).

We now specify which data to download.

$ betsy_run.py --network_png graph.png \
    --input GEOSeries \
    --output Heatmap \
    --mattr GSEID=GSE14934

Although --mattr can go anywhere in the argument list, I usually put
them at the end.

There are no more messages about missing --mattr arguments.  We now
see the line:
    Add --run when ready to run the analysis.

This means that BETSY has enough information to generate the pipeline
and is ready to run it.


5.  We now take one more look at graph.png to examine the
pipeline(s) created and make sure it is what we intended.  Since it
looks good, we now ask BETSY to run the pipeline by adding the "--run"
argument.

Although it is not necessary, we will also add a "--receipt" argument
so that BETSY will generate a text file record of what it did, and an
"--output_file" argument to tell BETSY where to save the output file.

$ betsy_run.py --network_png graph.png \
    --input GEOSeries \
    --output Heatmap --output_file heatmap.png \
    --receipt "GSE14934.heatmap.txt" \
    --mattr GSEID=GSE14934 \
    --run
# This will run for ~5 minutes.

If this ran successfully, BETSY:
a.  Downloaded the user submitted gene expression data for GEO recore
    GSE14934.
b.  Downloaded the annotations for this GEO record.
c.  Merged the gene expression with annotations.
d.  Log normalized the data.
e.  Plotted the heatmap.

Also, graph.png is now updated to show the pipeline that was run.


6.  Unfortuntely, this generated a heatmap that is too big to open on
my computer.  (Using ImageMagick, I can make a smaller file that can
open: convert heatmap.png -resize x1024 heatmap_smaller.png).  It
looks like BETSY made a heatmap that includes every gene on the array,
which isn't what I wanted.  The purpose of the heatmap is to show the
general expression pattern across the samples of the data set.  Thus,
it is better to filter for the most meaningful genes.  Specifically, I
would like to filter for just the genes with highest variance.

Examining the graph, I see that the Heatmap is generated from a
SignalFile DataType.  Further, the SignalFile has an attribute
called "filter_and_threshold" that is set to "no".  (TODO: BETSY needs
to define each of these attributes clearly.)  I'll asked BETSY to
filter the genes by setting this to "yes".

"filter_and_threshold" is an attribute on the SignalFile DataType.  To
ask BETSY to filter the SignalFile set, I use the "--dattr" or (d)ata
(attr)ibute argument thusly:

$ betsy_run.py --network_png graph.png \
    --input GEOSeries \
    --output Heatmap --output_file heatmap.png \
    --dattr SignalFile.filter_and_threshold=yes \
    --receipt "GSE14934.heatmap.txt" \
    --mattr GSEID=GSE14934

Again, the order of the arguments is important.  --dattr arguments
usually apply to the most recent DataType (specified as an --input or
--output).  So if GEOSeries had an attribute I wanted to set, I would
add the --dattr argument for the GEOSeries directly after the --input
argument.  However, in this case, since I would like to set the
attribute of a DataType in the graph that is not specified in either
the --input or --output, I put that at the end, after both --input and
--output.

After running this, I examine the graph closely to see what has
changed.  I verify that the "filter_and_threshold" data attribute is
now "yes".  Looking through the graph, I see that this is set by the
module "filter_and_threshold_genes", with several module attributes.
Looking through the BETSY knowledge base (by running betsy_run.py), I
find a description for what each of these attributes do.  To select
the most highly varying genes, I add "--mattr genes_with_highest_var=250".

$ betsy_run.py --network_png graph.png \
    --input GEOSeries \
    --output Heatmap --output_file heatmap.png \
    --dattr SignalFile.filter_and_threshold=yes \
    --receipt "GSE14934.heatmap.txt" \
    --mattr GSEID=GSE14934 \
    --mattr genes_with_highest_var=250

After verifying that the graph looks OK, I added "--run" to run this
pipeline.


7.  After the analysis is finished, the heatmap is starting to look
closer.  One thing that is commonly done when comparing the relative
patterns of expression, is to center and normalize the genes.  Using a
procedure similar to step 6, examining the graph and knowledge base,
we find that the way to ask BETSY to do this is:

$ betsy_run.py --network_png graph.png \
    --input GEOSeries \
    --output Heatmap --output_file heatmap.png \
    --dattr SignalFile.filter_and_threshold=yes \
    --dattr SignalFile.gene_center=mean \
    --dattr SignalFile.gene_normalize=variance \
    --receipt "GSE14934.heatmap.txt" \
    --mattr GSEID=GSE14934 \
    --mattr genes_with_highest_var=250 \
    --run


8.  Still not quite right.  Looks a bit messy.  Let's cluster it.

$ betsy_run.py --network_png graph.png \
    --input GEOSeries \
    --output Heatmap --output_file heatmap.png \
    --dattr Heatmap.cluster_alg=hierarchical \
    --dattr SignalFile.filter_and_threshold=yes \
    --dattr SignalFile.gene_center=mean \
    --dattr SignalFile.gene_normalize=variance \
    --receipt "GSE14934.heatmap.txt" \
    --mattr GSEID=GSE14934 \
    --mattr genes_with_highest_var=250 \
    --run


9.  Looks much better.  Now refining by playing around with attributes
for the "plot_cluster_heatmap" module.  (You can find this by running
betsy_run.py and searching through the results.)


$ betsy_run.py \
    --input GEOSeries \
    --output Heatmap --output_file heatmap.png \
    --dattr Heatmap.cluster_alg=hierarchical \
    --dattr SignalFile.filter_and_threshold=yes \
    --dattr SignalFile.gene_center=mean \
    --dattr SignalFile.gene_normalize=variance \
    --receipt "GSE14934.heatmap.txt" \
    --mattr GSEID=GSE14934 \
    --mattr genes_with_highest_var=250 \
    --mattr hm_width=100 \
    --mattr hm_color=brewer-rdbu-div \
    --mattr hm_colorbar=yes \
    --mattr hm_colorbar_height=1.5 \
    --run

This generates a nice hierarchically clustered heatmap.


10.  Finally, I want to play around with the processing of the gene
expression data.  Previously, BETSY opted to use the data that was
provided by the depositors.  However, I would like to see what the
data looks like if it is preprocessed with RMA.  To do this, I ask for
the SignalFile to be preprocessed with RMA:
    --dattr SignalFile.preprocess=rma


$ betsy_run.py --network_png graph.png \
    --input GEOSeries \
    --output Heatmap --output_file heatmap.png \
    --dattr Heatmap.cluster_alg=hierarchical \
    --dattr SignalFile.preprocess=rma \
    --dattr SignalFile.filter_and_threshold=yes \
    --dattr SignalFile.gene_center=mean \
    --dattr SignalFile.gene_normalize=variance \
    --receipt "GSE14934.heatmap.txt" \
    --mattr GSEID=GSE14934 \
    --mattr genes_with_highest_var=250 \
    --mattr hm_width=100 \
    --mattr hm_color=brewer-rdbu-div \
    --mattr hm_colorbar=yes \
    --mattr hm_colorbar_height=1.5 \
    --run

Taking a look at the graph generated, the pipeline now:

a.  Downloaded the supplementary files associated with GEO record
    GSE14934.
b.  Saw that it contained Affymetrix CEL files.  
c.  Examined the CEL files and determine that they were version cc1.
d.  Converted them to CEL version 3, since this is required for
    programs later in the pipeline.
e.  Preprocessed the CEL files by RMA.
f.  Log normalized the data.
g.  Filtered the data.
h.  Plotted the heatmap.



III.  BETSY COOKBOOK
====================

This section includes some generic BETSY rules that you can try out.
This is a work in progress, so please email if there are any problems
with these.  Also, please email if you have any to add.

There are examples of some file formats in Betsy/samples/.


A.  Run FastQC to check quality of a folder of FastQ files.

betsy_run.py \
  --input FastqFolder \
  --input SampleGroupFile \
  --output FastQCSummary

You will need to provide --input_file and --output_file arguments
describing where your files (or folders) are, e.g.:

  betsy_run.py \
    --input FastqFolder --input_file my_fastq_folder/ \
    --input SampleGroupFile --input_file samples.txt \
    --output FastQCSummary --output_file fastqc_results.xls

- FastqFolder is a folder (directory) of .fastq files (or compressed
  fastq files, e.g. .fastq.gz).
- SampleGroupFile is a file that links each fastq file with a sample
  name.  There is an example in Betsy/samples/.

For simplicity, we will leave out the --input_file and --output_file
in these commands.  BETSY can still generate the graphs without them.
However, before executing the pipelines, please fill in with your own
files.

This will run FastQC on each of the fastq files in your FastqFolder
and provide a summary of the results.  If you want the raw results
from FastQC, you can specify a FastQCFolder as the --output, e.g.:

  betsy_run.py \
    --input FastqFolder \
    --input SampleGroupFile \
    --output FastQCFolder


If you look at the results and decide you would like to see what
happens after trimming adapters, you can ask for the adapters to be
trimmed.  You will need to provide a fasta file with the adapter
sequences.  I use the one distributed with Trimmomatic.

  betsy_run.py \
    --input FastqFolder \
    --input SampleGroupFile \
    --output FastQCSummary \
    --dattr FastQCSummary.adapters_trimmed=yes \
    --mattr adapters_fasta=adapters/TruSeq3-PE-2.fa



B.  Preprocess RNA-Seq data starting from Fastq files.

betsy_run.py --network_png graph.png \
  --input FastqFolder \
  --input SampleGroupFile \
  --input ReferenceGenome \
  --input GTFGeneModel \
  --output SignalFile \
  --dattr SignalFile.preprocess=fpkm

This will generate a gene expression matrix (SignalFile) containing
the FPKM values.  Note from the terminal output (and from the graph)
that this will generate logged FPKM values.  If you don't want it to
be logged, then request for the SignalFile to be not logged:

  --dattr SignalFile.logged=no

Also, if you would like to get TPM, read counts, or counts per
million, you can specify one of:

  --dattr SignalFile.preprocess=tpm
  --dattr SignalFile.preprocess=counts
  --dattr SignalFile.preprocess=cpm

The pipelines will change to reflect the desired output.

Also note that these pipelines analyze the data without adapter
trimming.  To figure out how to request adapter trimming, let's start
by examining the graph.png created above.  Note that the SignalFile
data type that is generated does not have an attribute that controls
adapter trimming.  Thus, we cannot just set an attribute for
SignalFile.

While in principal each data type should contain attributes describing
every option used to create it, this would lead to data types that
contain a confusing number of attributes.  In this case, instead of
setting the attribute on the SignalFile at the end, we will configure
the "lowest" data type that contains the appropriate attribute.  In
this case, the RNASeqUnprocessedSignalFile node contains an
"adapters_trimmed" attribute.  This attribute is dropped (for
simplicity) when it gets converted to the next data type.  If we set:
  --dattr RNASeqUnprocessedSignalFile.adapters_trimmed=yes

... the backwards chainer will generate a pipeline that creates this
data object with adapters trimmed.

In this RNA-Seq analysis, the aligners require a GTFGeneModel to know
where the transcripts are in the genome.  This is just a GTF file that
is provided to the alignment algorithm.  These can be downloaded from
GENCODE, UCSC, or other databases, e.g.:
  gencodegenes.org -> Data : Human : Reference Releases : 19 -> 
    Comprehensive gene annotation (GTF)

The ReferenceGenome here can be either:
  1.  A FASTA formatted file that contains a reference genome,
      e.g. GRCh37.p13.genome.fa.
      If this is given, the BETSY  
  2.  A directory that contains the genome file along with the proper
      indexes.



C.  Creating pre-indexed reference genomes.

In recipe B above, you provide a ReferenceGenome.  Since the
RNA-Seq aligners (e.g. Tophat, STAR, etc.) require their own indexes
for the genome, BETSY will automatically create those indexes from the
ReferenceGenome.  BETSY will save those indexes in its cache and reuse
them the next time they are needed.

In practice, however, those indexes take a lot of disk space, and
sometimes I would like to use them outside of BETSY.  Thus, I usually
pre-index my references.

betsy_run.py \
  --input ReferenceGenome \
  --output FullyIndexedReferenceGenome --output_file <reference>

betsy_run.py \
  --input ReferenceGenome \
  --input GTFGeneModel \
  --output RSEMReferenceGenome --output_file <reference.rsem>

betsy_run.py \
  --input ReferenceGenome \
  --input GTFGeneModel \
  --output STARReferenceGenome --output_file <reference.star>

Note that the --output for an indexed "ReferenceGenome" is a
"FullyIndexedReferenceGenome".  This is for historical reasons and
may be changed in the future.

Now that we have the indexed reference genomes, we can ask BETSY to
use them when doing the RNA-Seq preprocessing.  The RNA-Seq recipe
(from above) then becomes:

betsy_run.py --network_png graph.png \
  --input FastqFolder \
  --input SampleGroupFile \
  --input ReferenceGenome \
  --input STARReferenceGenome --input_file <reference.star> \
  --input RSEMReferenceGenome --input_file <reference.rsem> \
  --input GTFGeneModel \
  --output SignalFile \
  --dattr SignalFile.preprocess=fpkm

We get a message that ReferenceGenome is no longer needed, so we can
remove it.  The final command is then:

betsy_run.py --network_png graph.png \
  --input FastqFolder \
  --input SampleGroupFile \
  --input STARReferenceGenome \
  --input RSEMReferenceGenome \
  --input GTFGeneModel \
  --output SignalFile \
  --dattr SignalFile.preprocess=fpkm




IV.  MANAGING CACHE
===================

When BETSY runs pipelines, it tries to avoiding repeating the same
calculation.  This enables the user to try multiple different
parameters without performing redundant calculations.  BETSY does this
by caching the results in the CACHE_PATH configured in ~/.betsyrc.
Because CACHE_PATH contains an archive of every result, it can grow
large.  Unfortunately, there is not yet an automated way of clearing
that cache, and it must be done manually using a script called
betsy_manage_cache.py

Here are some example uses of betsy_manage_cache.py.

betsy_manage_cache.py -h        Show a help message.
betsy_manage_cache.py           Generates a summary of the analyses that are 
                                cached.
betsy_manage_cache.py --run     Show the analyses currently running.
betsy_manage_cache.py --broken  Show the broken analyses, e.g. those that 
                                quit before completion for some reason.

betsy_manage_cache.py --clear_cache 1T 
                                Clear out 1 terabyte of old (not currently 
                                running) analyses.
betsy_manage_cache.py --clear_cache 500g
                                Clear out 500 Gb of old analyses.
betsy_manage_cache.py --clear_cache 500g --dry_run
                                Do a dry run.  Just show the analyses that 
                                would be deleted without actually deleting
                                them.


BETSY will clear the analyses that were least recently accessed.




Preprocess Usage

1)Betsy can preprocess with rma or mas5 for Affymetrix cel data. 

	Examples:
	A. When given a GSE ID from the geo, and want to do rma preprocess, 
	   the command is

	python run_rule.py  \
      --input 'GEOSeries' \
      --mattr 'GSEID=GSE8286' \
      --output 'SignalFile' \
      --dattr 'SignalFile,preprocess=rma' \
      --dattr 'SignalFile,quantile_norm=yes' \
      --png_file 'out.png'
      ----------------------------------------------------------------
      B. When given a GSE ID and GPL platform number from the geo, 
	   and want to do rma preprocess, 
	   the command is 
     
      python run_rule.py  \
      --input 'GEOSeries' \
      --mattr 'GSEID=GSE17907' \
      --mattr 'GPLID=GPL570' \
      --output 'SignalFile' \
      --dattr 'SignalFile,preprocess=rma' \
      --dattr 'SignalFile,quantile_norm=yes' \
      --png_file 'out.png'
      ----------------------------------------------------------------
     C. When given a folder contains cel file, the command is

	python run_rule.py  \
      --input 'CELFiles' \
      --input_file '/home/xchen/chencode/betsy_test/GSE8286_folder' \
      --output 'SignalFile' \
      --dattr 'SignalFile,preprocess=rma' \
      --dattr 'SignalFile,quantile_norm=yes' \
      --png_file 'out.png'
-----------------------------------------------------------------------
2) Betsy can preprocess with illumina for illumina idat files.
     Example:
	When given a folder contains idat files, the command is
     python run_rule.py  \
     --input 'ExpressionFiles'  \
     --input_file '/home/xchen/chencode/betsy_test/6991010018' \
     --output 'SignalFile'  \
     --dattr 'SignalFile,preprocess=illumina' \
     --png_file 'out.png'
 ----------------------------------------------------------------
3) Betsy can preprocess with agilent for  Agilent files.
     Example:
	When given a folder contains agilent files, the command is
     python run_rule.py \
     --input 'ExpressionFiles' \
     --input_file '/home/xchen/chencode/betsy_test/agilent_expression' \
     --output 'SignalFile' \
     --dattr 'SignalFile,preprocess=agilent' \
     --png_file 'out.png'
 ----------------------------------------------------------------
4) Betsy can preprocess with gpr for gpr files.
     Example:
	When given a folder contains gpr files, the command is
     python run_rule.py \
     --input 'ExpressionFiles'  \
     --input_file '/home/xchen/chencode/betsy_test/GSE4189' \
     --output 'SignalFile' \
     --dattr 'SignalFile,preprocess=loess' \
     --png_file 'out.png'
 ----------------------------------------------------------------  
 (5) Betsy can download TCGA data and process it to a SignalFile
    Example:
   python run_rule.py \
   --input 'TCGAID'  \
   --mattr 'disease=BLCA' \
   --output 'SignalFile'  \
   --dattr 'SignalFile,preprocess=tcga' \
   --dattr 'TCGAFile,data=rppa' \
   --png_file 'out.png' 
----------------------------------------------------------------
(6) Betsy can preprocess RNA Seq with RSEM and convert into a SignalFile
 
    python run_rule.py \
   --input 'RNASeqFile' \
   --input_file '/home/xchen/NGS/try_RSEM/big_sample_data' \
   --output 'SignalFile' \
   --dattr SignalFile,preprocess=rsem \
   --dattr SamFolder,ref=human \
   --input SampleGroupFile \
   --input_file '/home/xchen/NGS/try_RSEM/big_sample_data/sample_group.txt' \
   --png_file 'out.png'
=============================================================================
Process Usage

Betsy can do predataset,log,unlog,gene_filter,quantile,combat, shiftscale,dwd,bfrm, predataset,gene_center,gene_normalize,gene_order, annotate, rename_sample, platform,
num_features,unique_genes, duplicate_probe,group_fc,change format,for signal files

The option of the attributes are:
    preprocess:   unknown, illumina, agilent, mas5, rma, loess
    missing_algorithm: none, median_fill, zero_fill         
    filter:no, yes 
    dwd_norm: no, yes
    bfrm_norm: no, yes
    quantile_norm: no, yes
    shiftscale_norm: no, yes
    combat_norm: no", yes
    predataset: no, yes
    gene_center: no, mean, median
    gene_normalize:  no, variance, sum_of_squares
    gene_order:no, class_neighbors, gene_list, t_test_p, t_test_fdr
    annotate: no,yes
    rename_sample: no, yes
    platform: yes,no
    num_features: yes,no
    unique_genes: no, average_genes, high_var, first_gene,
    duplicate_probe:no, closest_probe, high_var_probe    
    group_fc: yes,no
    contents:unspecified, train0, train1, test, class0,class1,test,
        class0, class1, class0,class1,      
    logged: no, yes
    format: tdf, gct

 ----------------------------------------------------------------
    Example:
    When given a SignalFile,do predataset, quantile, gene_center=mean,gene_normalize=variance.
    The command is
    python run_rule.py \
    --input '_SignalFile_Postprocess' \
    --input_file '/home/xchen/chencode/betsy_test/all_aml_train_missed.gct' \
    --output 'SignalFile' \
    --dattr 'SignalFile,predataset=yes' \
    --dattr 'SignalFile,quantile_norm=yes' \
    --dattr 'SignalFile,gene_center=mean' \
    --dattr 'SignalFile,gene_normalize=variance'
 ----------------------------------------------------------------
    When given a SignalFile and ClassLabelFile, group_fc=yes and group_fc_num=1
    The command is:
	python run_rule.py \
	--input '_SignalFile_Postprocess' \
	--input_file '/home/xchen/chencode/betsy_test/all_aml_train_filt.res' \
	--input 'ClassLabelFile' \
	--dattr 'cls_format=cls' \
	--input_file '/home/xchen/chencode/betsy_test/all_aml_train.cls' \
	--output 'SignalFile' \
	--dattr 'SignalFile,group_fc=yes' \
	--mattr 'group_fc_num=1' \
	--png_file 'out.png'
=============================================================================
Heatmap Usage

Betsy can make heatmap for a SignalFile without clustering.
    Example:
    When given a signal_file, plot the heatmap and set the heatmap size as x=20,y=20.
    The command is:
	python run_rule.py \
	--input '_SignalFile_Postprocess' \
	--input_file '/home/xchen/chencode/betsy_test/breast_19.mas5'  \
	--output 'Heatmap'   \
     --mattr 'hm_width=20' \
     --mattr 'hm_height=20' \
     --png_file 'out.png'

   
    The result folder will contain a png file showing the heatmap.
=============================================================================
Clustering Usage

Betsy can do clustering for a SignalFile and plot the heatmap.

    Example:
    When given a signalFile, gene_center=mean, gene_normalize=variance, 
    cluster the genes by hierarchical method and plot the heatmap, 
    set the heatmap size as x=200,y=1.
    The command is:
	python run_rule.py \
	--input '_SignalFile_Postprocess'  \
	--input_file '/home/xchen/chencode/betsy_test/breast_19.mas5'  \
	--output 'ClusterReportFile'   \
     --dattr 'SignalFile,gene_normalize=variance' \
     --dattr 'SignalFile,gene_center=mean' \
	--dattr 'ClusterFile,cluster_alg=pca' \
	--dattr 'ClusterFile,distance=correlation' \
     --mattr 'hm_width=200' \
     --mattr 'hm_height=20' \
	--png_file 'out.png'

The result folder will contain a clustering file and a png file showing the heatmap.
===============================================================================
Classification Usage

Betsy can do classification with svm and weighted_voting method for dataset. 
Also it can leave one out cross validation by these two methods.
The command is:
	python run_rule.py \
	--input '_SignalFile_Postprocess' \
	--dattr 'contents=class0,class1' \
	--input_file '/home/xchen/chencode/betsy_test/all_aml_train.res' \
	--input '_SignalFile_Postprocess' \
	--dattr 'contents=test' \
	--input_file '/home/xchen/chencode/betsy_test/all_aml_test.res' \
	--input 'ClassLabelFile' \
	--dattr 'contents=class0,class1' \
	--dattr 'cls_format=cls' \
	--input_file '/home/xchen/chencode/betsy_test/all_aml_train.cls' \
	--input 'ClassLabelFile' \
	--dattr 'contents=test' \
	--dattr 'cls_format=cls' \
	--input_file '/home/xchen/chencode/betsy_test/all_aml_test.cls' \
	--output 'ClassifyReportFile' \
	--png_file 'out.png' \
	--text_file 'out.txt' 

===============================================================================
Differential expressed genes analysis usage

Betsy can do the differential expressed genes analysis for signal_files.
The command is:
	python run_rule.py \
	--input '_SignalFile_Postprocess'  \
	--input_file '/home/xchen/chencode/betsy_test/all_aml_train_filt.res' \
	--input 'ClassLabelFile' \
	--dattr 'cls_format=cls' \
	--input_file '/home/xchen/chencode/betsy_test/all_aml_train.cls' \
	--output 'DiffReportFile'  \
	--png_file 'out.png'
===============================================================================
Geneset Analysis Usage 

Example:
When given a signal_file and a gene set file, try do geneset score analysis and plot the result.

	python run_rule.py \
	--output 'GenesetReportFile' \
	--dattr 'SignalFile,quantile_norm=yes' \
	--dattr 'SignalFile,gene_center=mean' \
        --dattr 'SignalFile,gene_normalize=variance' \
	--dattr 'SignalFile,unique_genes=high_var' \
	--dattr 'SignalFile,annotate=yes'  \
	--input '_SignalFile_Postprocess'  \
	--input_file '/home/xchen/chencode/betsy_test/se2fplate6_48.illu.gz' \
	--input 'GenesetFile' \
	--input_file '/home/xchen/chencode/betsy_test/genesets.gmt' \
	--mattr 'geneset_value=E2F1n_affy_150_UP' \
	--png_file 'out.png'
===============================================================================
Normalization Usage

Example:
When given a signal_file, try do quantile_norm and gene_center=median,get a normalization report

	python run_rule.py \
	--input '_SignalFile_Postprocess'  \
	--input_file '/home/xchen/chencode/betsy_test/all_aml_train_filt.res' \
	--output 'NormalizeReportFile'  \
	--dattr 'SignalFile,quantile_norm=yes'  \
	--dattr 'SignalFile,preprocess=unknown' \
	--dattr 'SignalFile,gene_center=median' \
	--png_file 'out.png' \
      --json_file 'outjson.txt'
--------------------------------------------------
	When given a ExpressionFiles, try rma preprocess, do quantile_norm and gene_center=median,get a NormalizeReportFile report

	python run_rule.py \
	--input 'ExpressionFiles'  \
	--input_file '/home/xchen/chencode/betsy_test/GSE8286_folder' \
	--output 'NormalizeReportFile'  \
	--dattr 'SignalFile,quantile_norm=yes'  \
	--dattr 'NormalizeReportFile,preprocess=rma' \
	--dattr 'SignalFile,gene_center=median' \
	--png_file 'out.png'
--------------------------------------------------
	When given a ExpressionFiles, try illumina preprocess, do quantile_norm and gene_center=median,get a NormalizeReportFile report

	python run_rule.py \
	--input 'ExpressionFiles'  \
	--input_file '/home/xchen/chencode/betsy_test/6991010018' \
	--output 'NormalizeReportFile'  \
	--dattr 'SignalFile,quantile_norm=yes'  \
	--dattr 'NormalizeReportFile,preprocess=illumina' \
	--dattr 'SignalFile,gene_center=median' \
	--png_file 'out.png'
==============================================================================
DNA NGS Usage

When given a DNA fa file, require a vcf file.
	python run_rule.py \
	--output VcfFile \
	--dattr  VcfFile,vcf_filter=yes \
	--input FastqFile --input_file /data/xchen/human/human1_cut.fa \
	--png_file out.png
==============================================================================
Clinical outcomes Usage

Given an expression file and clinical file, doing clinical outcome analysis.
	python run_rule.py \
	--input _SignalFile_Postprocess \
	--input_file  /home/xchen/chencode/examples/survial_analysis/GSE17907.rma.gz \
	--input ClinicalFile \
	--input_file /home/xchen/chencode/examples/survial_analysis/GSE17907.stdclin \
	--mattr outcome=DMFS \
	--mattr dead=DMFS_DEAD \
	--mattr genename=117_at,1007_s_at \
	--output ClinicalAnalysis   \
	--png_file out.png --text_file 1.txt
==============================================================================
EMT analysis Usage

Given an expression file and a cellType File, do EMT analysis on some genesets.

python run_rule.py \
	--input _SignalFile_Postprocess  \
	--input_file /data/genomidata/stem_cell/EMT.cent.rma.gz \
	--input CellTypeFile \
	--input_file /data/genomidata/stem_cell/EMT.stdclin  \
	--output EMTAnalysis \
	--png_file 'out.png' \
	--mattr 'geneset_value=CDH1,CDH2,VIM,ABCA1' \
	--output_file 'text0'
==============================================================================
Pathway Signature Score Usage

	python run_rule.py \
	--input 'ExpressionFiles' \
	--input_file '/home/xchen/chencode/betsy_test/GSE8286_folder' \
	--output 'SignatureScore'  \
	--mattr 'platform_name=HG_U133A' \
	--png_file 'out.png' --text_file 'out.txt' 
==============================================================================
Batch effect remove usage

Betsy can do the batch effect remove analysis for signal_files.
The command is:
	python run_rule.py \
	--input '_SignalFile_Postprocess'  \
	--input_file '/home/xchen/chencode/betsy_test/all_aml_train_filt.res' \
	--input 'ClassLabelFile' \
	--dattr 'cls_format=cls' \
	--input_file '/home/xchen/chencode/betsy_test/all_aml_train.cls' \
	--output 'BatchEffectReportFile'  \
	--png_file 'out.png'
