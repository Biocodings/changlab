# TODO: Make a constant for ["yes", "no"]

# DataTypes:
# VCFFolder
# VCFRecalibrationReport
# AnnotatedVCFFolder      # No.  Not VCF files.  Need to clean this up.
# MultiVCFFile
# AnnotatedMultiVCFFile   # No.  Not VCF files.  Need to clean this up.
# MultiVCFFolder          # folder of VCFFolder's, from different callers
#
# BackfillMultiVCFFile
#
# PileupSummary
# PositionsFile
#
# Modules:
# summarize_variants_mpileup
# call_variants_mpileup
# call_variants_GATK
# call_variants_platypus
# call_consensus_varscan
# call_variants_varscan
# call_variants_mutect
# call_variants_strelka
# call_variants_somaticsniper
# call_variants_jointsnvmix
# merge_somatic_variants
#
# make_vcf_recalibration_report_snp
# recalibrate_variants_snp
# filter_snps_only_multivcf
# annotate_with_annovar
# merge_vcf_folder
# annotate_multivcf_annovar
# extract_positions_from_multivcf_file
# backfill_vcf_folder
#
# 
# Recalibrate variant scores with GATK.
# https://www.broadinstitute.org/gatk/guide/article?id=2805
    

from Betsy.bie3 import *
import BasicDataTypes as BDT
import BasicDataTypesNGS as NGS

CALLERS = [
    "none", "mpileup", "gatk", "platypus", "varscan", "mutect", "strelka",
    "somaticsniper", "jointsnvmix"]
VARTYPES = ["all", "snp", "indel", "consensus"]
VARTYPE_NOT_CONSENSUS = [x for x in VARTYPES if x != "consensus"]
BACKFILLS = ["no", "yes", "consensus"]

## BCFFolder = DataType(
##     "BCFFolder",
##     AttributeDef(
##         "contents", BDT.CONTENTS,
##         "unspecified", "unspecified", help="contents"),
##     AttributeDef(
##         "vartype", ["both", "snp", "indel"], "both", "snp",
##         help="What kind of variants are held in this file."),
##     AttributeDef(
##         "get_coverage", ["no", "yes"], "no", "no",
##         help="Whether the purpose is to get depth of coverage."),
##     help="Folder of .bcf files generated by samtools mpileup.",
##     )


VCFFolder = DataType(
    "VCFFolder",
    AttributeDef(
        "contents", BDT.CONTENTS, "unspecified", "unspecified",
        help="contents"),
    AttributeDef(
        "caller", CALLERS, "none", "mpileup",
        help="Which variant caller was used."),

    #AttributeDef(
    #    "mpileup_summary", ["no", "yes"], "no", "no",
    #    help="Whether this is just summary information from mpileup."),
    AttributeDef(
        "vartype", VARTYPES, "snp", "snp",
        help="What kind of variants are held in this file."),
    AttributeDef(
        "vcf_recalibrated", ["no", "yes"], "no", "no",
        help="Whether quality scores are ready for filtering."),
    AttributeDef(
        "somatic", ["no", "yes"], "no", "no",
        help="Whether the variants here are from the somatic cancer genome "
        "(no germline)."),
    AttributeDef(
        "backfilled", BACKFILLS, "no", "no",
        help="Whether the mutations are backfilled."),
    )

VCFRecalibrationReport = DataType(
    "VCFRecalibrationReport",
    AttributeDef(
        "vartype", VARTYPES, "snp", "snp",
        help="What kind of variants are held in this file."),
    AttributeDef(
        "somatic", ["no", "yes"], "no", "no",
        help="Whether the variants here are from the somatic cancer genome "
        "(no germline)."),
    AttributeDef(
        "caller", CALLERS, "none", "mpileup",
        help="Which variant caller was used."),
    )

AnnotatedVCFFolder = DataType(
    "AnnotatedVCFFolder",
    )

MultiVCFFile = DataType(
    "MultiVCFFile",
    # Headers are:
    # #CHROM POS ID REF ALT QUAL FILTER INFO FORMAT [Samples...]
    AttributeDef(
        "contents", BDT.CONTENTS, "unspecified", "unspecified",
        help="contents"),
    AttributeDef(
        "caller", CALLERS, "none", "mpileup",
        help="Which variant caller was used."),
    AttributeDef(
        "vartype", VARTYPES, "snp", "snp",
        help="What kind of variants are held in this file."),
    AttributeDef(
        "somatic", ["no", "yes"], "no", "no",
        help="Whether the variants here are from the somatic cancer genome "
        "(no germline)."),
    AttributeDef(
        "backfilled", ["no", "yes", "consensus"],
        # na         backfill is irrelevant for this pipeline
        # missing    not yet backfilled
        # filled     backfilled
        # consensus  contains information that can be used for backfill
        "no", "no",
        #"backfilled", ["no", "yes"], "no", "no",
        help="Whether the mutations are backfilled."),
    #AttributeDef(
    #    "backfilled", ["no", "yes"], "no", "no",
    #    help="Whether the mutations are backfilled."),
    )

AnnotatedMultiVCFFile = DataType(
    "AnnotatedMultiVCFFile",
    #AttributeDef(
    #    "backfilled", ["no", "yes"], "no", "no",
    #    help="Whether the mutations are backfilled."),
    )

PileupSummary = DataType(
    "PileupSummary",
    AttributeDef(
        "contents", BDT.CONTENTS, "unspecified", "unspecified",
        help="contents"),
    AttributeDef(
        "vartype", VARTYPES, "snp", "snp",
        help="What kind of variants are held in this file."),
    )

# For samtools.  Two columns (no header):
# <chrom>  <pos 0-based>  
PositionsFile = DataType(
    "PositionsFile",
    AttributeDef(
        "vartype", VARTYPES, "snp", "snp",
        help="What kind of variants are held in this file."),
    )

NormalCancerFile = DataType(
    "NormalCancerFile",
    #AttributeDef(
    #    "mouse_reads_subtracted", ["yes", "no"], "no", "no",
    #    help="For subtracting mouse reads from PDX models of FastqFolder"),
    help="File contains correspondence between tumor and normal samples.  "
    "Should be a tab-delimited text file (or Excel file) containing two "
    'columns with headers "Normal" and "Cancer".  The "Normal" column '
    'contains the name of the normal sample.  The "Cancer" column '
    "contains the name of the cancer sample.  The corresponding BAM files "
    "should be named <sample>.bam."
    )

# To tell MuTect where to search.
IntervalListFile = DataType(
    "IntervalListFile",
    help="Genomic intervals in GATK format."
    )

MultiVCFFolder = DataType(
    "MultiVCFFolder",
    )


all_data_types=[
    VCFFolder,
    VCFRecalibrationReport,
    AnnotatedVCFFolder,
    MultiVCFFile,
    AnnotatedMultiVCFFile,
    MultiVCFFolder,

    NormalCancerFile,
    PileupSummary,
    PositionsFile,
    IntervalListFile,
    ]

all_modules = [
    ModuleNode(
        "call_variants_mpileup",
        [NGS.BamFolder, NGS.ReferenceGenome], VCFFolder,
        #OptionDef("max_read_depth", default=100),
        
        #Constraint("contents", CAN_BE_ANY_OF, BDT.CONTENTS, 0),
        #Consequence("contents", SAME_AS_CONSTRAINT),
        Constraint("sorted", MUST_BE, "coordinate", 0),
        Constraint("samtools_indexed", MUST_BE, "yes", 1),
        Consequence("caller", SET_TO, "mpileup"),
        Consequence("vcf_recalibrated", SET_TO, "no"),
        Consequence("vartype", SET_TO, "all"),
        help="Use samtools mpileup to call variants."),
    ModuleNode(
        "summarize_consensus_mpileup",
        [NGS.BamFolder, NGS.ReferenceGenome, PositionsFile], PileupSummary,
        Constraint("sorted", MUST_BE, "coordinate", 0),
        Constraint("duplicates_marked", MUST_BE, "yes", 0),
        Constraint("has_read_groups", MUST_BE, "yes"),
        Constraint("indexed", CAN_BE_ANY_OF, ["no", "yes"], 0),
        Constraint("samtools_indexed", MUST_BE, "yes", 1),

        #Constraint("contents", CAN_BE_ANY_OF, BDT.CONTENTS),
        #Consequence("contents", SAME_AS_CONSTRAINT),
        #Consequence("caller", SET_TO, "mpileup"),
        #Consequence("mpileup_summary", SET_TO, "yes"),
        #Consequence("vartype", SET_TO_ONE_OF, ["all", "consensus"]),
        Constraint("vartype", CAN_BE_ANY_OF, VARTYPE_NOT_CONSENSUS, 2),
        Consequence("vartype", SET_TO, "consensus"),
        help="Use mpileup to summarize mapped reads."),
    ModuleNode(
        "summarize_reads_mpileup",
        [NGS.BamFolder, NGS.ReferenceGenome], PileupSummary,
        Constraint("sorted", MUST_BE, "coordinate", 0),
        Constraint("duplicates_marked", MUST_BE, "yes", 0),
        Constraint("has_read_groups", MUST_BE, "yes"),
        Constraint("indexed", CAN_BE_ANY_OF, ["no", "yes"], 0),
        Constraint("samtools_indexed", MUST_BE, "yes", 1),
        #Constraint("vartype", CAN_BE_ANY_OF, ["snp", "indel"], 2),
        #Consequence("vartype", SAME_AS_CONSTRAINT),
        help="Use mpileup to summarize mapped reads."),

    ModuleNode(
        "call_variants_GATK",
        [NGS.BamFolder, NGS.ReferenceGenome], VCFFolder,
        
        # Pipeline: read groups -> sort -> mark dups -> realign ->
        # recalibrate -> call variants
        #Constraint("contents", CAN_BE_ANY_OF, BDT.CONTENTS, 0),
        #Consequence("contents", SAME_AS_CONSTRAINT),
        Constraint("sorted", MUST_BE, "coordinate", 0),
        Constraint("has_read_groups", MUST_BE, "yes", 0),
        Constraint("duplicates_marked", MUST_BE, "yes", 0),
        Constraint("indel_realigned", MUST_BE, "yes", 0),
        Constraint(
            "base_quality_recalibrated", CAN_BE_ANY_OF, ["no", "yes"], 0),
        Constraint("dict_added", MUST_BE, "yes", 1),
        Constraint("samtools_indexed", MUST_BE, "yes", 1),
        
        Consequence("caller", SET_TO, "gatk"),
        Consequence("vcf_recalibrated", SET_TO, "no"),
        Consequence("vartype", SET_TO, "all"),
        help="Use GATK HaplotypeCaller to call variants."),
    ModuleNode(
        "call_variants_platypus",
        [NGS.BamFolder, NGS.ReferenceGenome], VCFFolder,
        
        #Constraint("contents", CAN_BE_ANY_OF, BDT.CONTENTS, 0),
        #Consequence("contents", SAME_AS_CONSTRAINT),
        Constraint("sorted", MUST_BE, "coordinate", 0),
        Constraint("indexed", MUST_BE, "yes", 0),
        Constraint("duplicates_marked", CAN_BE_ANY_OF, ["yes", "no"], 0),
        Constraint("has_read_groups", CAN_BE_ANY_OF, ["yes", "no"], 0),
        
        Constraint("dict_added", MUST_BE, "yes", 1),
        Constraint("samtools_indexed", MUST_BE, "yes", 1),
        Consequence("caller", SET_TO, "platypus"),
        Consequence("vcf_recalibrated", SET_TO, "no"),
        Consequence("vartype", SET_TO, "snp"),
        help="Use GATK HaplotypeCaller to call variants."),

    ModuleNode(
        "call_consensus_varscan",
        PileupSummary, VCFFolder,
        
        #Constraint("contents", CAN_BE_ANY_OF, BDT.CONTENTS, 0),
        #Consequence("contents", SAME_AS_CONSTRAINT),
        Constraint("vartype", MUST_BE, "consensus"),
        Consequence("vartype", SAME_AS_CONSTRAINT),
        #Constraint("samtools_indexed", MUST_BE, "yes", 1),
        Consequence("caller", SET_TO, "varscan"),
        Consequence("vcf_recalibrated", SET_TO, "no"),
        Consequence("backfilled", SET_TO, "consensus"),
        help="Use Varscan to generate consensus information."),

    ModuleNode(
        "call_variants_varscan",
        PileupSummary, VCFFolder,
        
        #Constraint("contents", CAN_BE_ANY_OF, BDT.CONTENTS, 0),
        #Consequence("contents", SAME_AS_CONSTRAINT),
        Constraint("vartype", CAN_BE_ANY_OF, ["snp", "indel"]),
        Consequence("vartype", SAME_AS_CONSTRAINT),
        #Constraint("samtools_indexed", MUST_BE, "yes", 1),
        Consequence("caller", SET_TO, "varscan"),
        Consequence("vcf_recalibrated", SET_TO, "no"),
        help="Use Varscan to call variants."),

    ModuleNode(
        "call_somatic_varscan",
        [PileupSummary, NormalCancerFile], VCFFolder,
        
        #Constraint("contents", CAN_BE_ANY_OF, BDT.CONTENTS, 0),
        #Consequence("contents", SAME_AS_CONSTRAINT),
        Constraint("vartype", CAN_BE_ANY_OF, ["snp", "indel"], 0),
        Consequence("vartype", SAME_AS_CONSTRAINT),
        #Constraint("samtools_indexed", MUST_BE, "yes", 1),
        Consequence("caller", SET_TO, "varscan"),
        Consequence("vcf_recalibrated", SET_TO, "no"),
        Consequence("somatic", SET_TO, "yes"),
        help="Use Varscan to call variants."),

    ModuleNode(
        "make_full_genome_intervals",
        NGS.ReferenceGenome, IntervalListFile,
        ),

    ModuleNode(
        "call_variants_mutect",
        [NGS.BamFolder, NormalCancerFile, NGS.ReferenceGenome,
         IntervalListFile], VCFFolder,
        OptionDef("mutect_cosmic_vcf"),
        OptionDef("mutect_dbsnp_vcf"),
        #Constraint("contents", CAN_BE_ANY_OF, BDT.CONTENTS, 0),
        #Consequence("contents", SAME_AS_CONSTRAINT),
        Constraint("sorted", MUST_BE, "coordinate", 0),
        Constraint("indexed", MUST_BE, "yes", 0),
        Constraint("duplicates_marked", CAN_BE_ANY_OF, ["yes", "no"], 0),
        Constraint("has_read_groups", CAN_BE_ANY_OF, ["yes", "no"], 0),
        Constraint("dict_added", MUST_BE, "yes", 2),
        Constraint("samtools_indexed", MUST_BE, "yes", 2),
        Consequence("caller", SET_TO, "mutect"),
        Consequence("vcf_recalibrated", SET_TO, "no"),
        Consequence("vartype", SET_TO, "snp"),
        Consequence("somatic", SET_TO, "yes"),
        help="Use MuTect to call variants.",
        ),

    ModuleNode(
        "call_variants_strelka",
        [NGS.BamFolder, NormalCancerFile, NGS.ReferenceGenome],
        VCFFolder,
        OptionDef(
            "strelka_skip_depth_filter", default="no",
            help='Set to "yes" for exome or other targeted sequencing.'),
        # Not sure if the BAM files need to be sorted or indexed.
        Constraint("sorted", MUST_BE, "coordinate", 0),
        Constraint("indexed", MUST_BE, "yes", 0),
        Constraint("duplicates_marked", CAN_BE_ANY_OF, ["yes", "no"], 0),
        Constraint("has_read_groups", CAN_BE_ANY_OF, ["yes", "no"], 0),
        Constraint("aligner", MUST_BE, "bwa_mem", 0),
        Consequence("caller", SET_TO, "strelka"),
        Consequence("vcf_recalibrated", SET_TO, "no"),
        Consequence("vartype", SET_TO_ONE_OF, ["snp", "indel"]),
        Consequence("somatic", SET_TO, "yes"),
        help="Use Strelka to call variants.",
        ),

    ModuleNode(
        "call_variants_somaticsniper",
        [NGS.BamFolder, NormalCancerFile, NGS.ReferenceGenome],
        VCFFolder,
        # Not sure if the BAM files need to be sorted or indexed.
        Constraint("sorted", MUST_BE, "coordinate", 0),
        Constraint("indexed", MUST_BE, "yes", 0),
        Constraint("duplicates_marked", CAN_BE_ANY_OF, ["yes", "no"], 0),
        Constraint("has_read_groups", CAN_BE_ANY_OF, ["yes", "no"], 0),
        Consequence("caller", SET_TO, "somaticsniper"),
        Consequence("vcf_recalibrated", SET_TO, "no"),
        Consequence("vartype", SET_TO, "snp"),
        Consequence("somatic", SET_TO, "yes"),
        help="Use SomaticSniper to call variants.",
        ),

    ModuleNode(
        "call_variants_jointsnvmix",
        [NGS.BamFolder, NormalCancerFile, NGS.ReferenceGenome],
        VCFFolder,
        # BAM files need to be indexed, duplicates_marked.
        # Reference must be samtools_indexed.
        Constraint("sorted", MUST_BE, "coordinate", 0),
        Constraint("indexed", MUST_BE, "yes", 0),
        Constraint("duplicates_marked", MUST_BE, "yes", 0),
        Constraint("has_read_groups", CAN_BE_ANY_OF, ["yes", "no"], 0),
        Constraint("samtools_indexed", MUST_BE, "yes", 2),
        Consequence("caller", SET_TO, "jointsnvmix"),
        Consequence("vcf_recalibrated", SET_TO, "no"),
        Consequence("vartype", SET_TO_ONE_OF, ["snp", "indel", "all"]),
        Consequence("somatic", SET_TO, "yes"),
        help="Use JointSNVMix (museq) to call variants.",
        ),

    ModuleNode(
        "merge_somatic_variants",
        [
            VCFFolder, # MuTect
            VCFFolder, # Varscan
            VCFFolder, # Strelka
            VCFFolder, # SomaticSniper
            VCFFolder, # JointSNVMix
            ],
        MultiVCFFolder,
        Constraint("caller", MUST_BE, "mutect", 0),
        Constraint("vartype", MUST_BE, "snp", 0),
        Constraint("somatic", MUST_BE, "yes", 0),
        Constraint("caller", MUST_BE, "varscan", 1),
        Constraint("vartype", MUST_BE, "snp", 1),
        Constraint("somatic", MUST_BE, "yes", 1),
        Constraint("caller", MUST_BE, "strelka", 2),
        Constraint("vartype", MUST_BE, "snp", 2),
        Constraint("somatic", MUST_BE, "yes", 2),
        Constraint("caller", MUST_BE, "somaticsniper", 3),
        Constraint("vartype", MUST_BE, "snp", 3),
        Constraint("somatic", MUST_BE, "yes", 3),
        Constraint("caller", MUST_BE, "jointsnvmix", 4),
        Constraint("vartype", MUST_BE, "snp", 4),
        Constraint("somatic", MUST_BE, "yes", 4),
        help="Call variants with all implemented somatic variant callers.",
        ),

    ModuleNode(
        "make_vcf_recalibration_report_snp",
        [VCFFolder, NGS.ReferenceGenome], VCFRecalibrationReport,
        OptionDef("vcf_recal_dbsnp"),
        OptionDef("vcf_recal_mills_indels"),
        OptionDef("vcf_recal_1kg_indels"),
        OptionDef("vcf_recal_omni"),
        Constraint("vcf_recalibrated", MUST_BE, "no", 0),
        Constraint("vartype", CAN_BE_ANY_OF, ["all", "snp"], 0),
        Consequence("vartype", SET_TO, "snp"),
        Constraint("somatic", CAN_BE_ANY_OF, ["yes", "no"], 0),
        Consequence("somatic", SAME_AS_CONSTRAINT),
        Constraint("caller", CAN_BE_ANY_OF, CALLERS, 0),
        Consequence("caller", SAME_AS_CONSTRAINT),
        help="VariantRecalibrator",
        ),
    ModuleNode(
        "recalibrate_variants_snp",
        [VCFFolder, NGS.ReferenceGenome, VCFRecalibrationReport], VCFFolder,
        Constraint("vcf_recalibrated", MUST_BE, "no", 0),
        Consequence("vcf_recalibrated", SET_TO, "yes"),
        Constraint("caller", CAN_BE_ANY_OF, CALLERS, 0),
        Constraint("caller", SAME_AS, 0, 2),
        Consequence("caller", SAME_AS_CONSTRAINT),
        Constraint("vartype", CAN_BE_ANY_OF, ["all", "snp"], 0),
        Constraint("vartype", MUST_BE, "snp", 2),
        Consequence("vartype", SAME_AS_CONSTRAINT, 2),
        Constraint("somatic", CAN_BE_ANY_OF, ["yes", "no"], 0),
        Constraint("somatic", SAME_AS, 0, 2),
        Consequence("somatic", SAME_AS_CONSTRAINT),
        help="GATK ApplyRecalibration",
        ),
    
    ModuleNode(
        "filter_snps_only_multivcf",
        MultiVCFFile, MultiVCFFile,
        Constraint("vartype", MUST_BE, "all"),
        Consequence("vartype", SET_TO, "snp"),
        ),

    ModuleNode(
        "annotate_with_annovar",
        VCFFolder, AnnotatedVCFFolder,
        OptionDef("buildver", help="E.g. hg19.  See annovar docs."),
        ),

    ModuleNode(
        "merge_vcf_folder",
        VCFFolder, MultiVCFFile,
        Constraint("contents", CAN_BE_ANY_OF, BDT.CONTENTS),
        Consequence("contents", SAME_AS_CONSTRAINT),
        Constraint("caller", CAN_BE_ANY_OF, CALLERS),
        Consequence("caller", SAME_AS_CONSTRAINT),
        Constraint("vartype", CAN_BE_ANY_OF, VARTYPES),
        Consequence("vartype", SAME_AS_CONSTRAINT),
        Constraint("backfilled", CAN_BE_ANY_OF, BACKFILLS),
        Consequence("backfilled", SAME_AS_CONSTRAINT),
        ),
    
    ModuleNode(
        "annotate_multivcf_annovar",
        MultiVCFFile, AnnotatedMultiVCFFile,
        OptionDef("buildver", help="E.g. hg19.  See annovar docs."),
        ),
    
    ModuleNode(
        "extract_positions_from_multivcf_file",
        MultiVCFFile, PositionsFile,
        #Constraint("backfilled", MUST_BE, "no"),
        Constraint("caller", CAN_BE_ANY_OF, CALLERS),
        Constraint("vartype", CAN_BE_ANY_OF, VARTYPES),
        Consequence("vartype", SAME_AS_CONSTRAINT),
        ),

    ModuleNode(
        "backfill_vcf_folder",
        # The first one will be backfilled with the information from
        # the second.
        [VCFFolder, VCFFolder], VCFFolder,
        OptionDef(
            "backfill_common_only", default="no",
            help="Backfill the samples that are in common.  Ignore samples "
            'that only occur in one file.  Must be "yes" or "no".'),
        DefaultAttributesFrom(0),
        Constraint("backfilled", MUST_BE, "no", 0),
        Consequence("backfilled", SET_TO, "yes"),
        Constraint("vartype", CAN_BE_ANY_OF, VARTYPE_NOT_CONSENSUS, 0),
        Consequence("vartype", SAME_AS_CONSTRAINT),
        Constraint("caller", CAN_BE_ANY_OF, CALLERS, 0),
        Consequence("caller", SAME_AS_CONSTRAINT),
        Constraint("backfilled", MUST_BE, "consensus", 1),
        Constraint("vartype", MUST_BE, "consensus", 1),
        Constraint("caller", CAN_BE_ANY_OF, CALLERS, 1),
        ),
    #ModuleNode(
    #    "backfill_multivcf_file",
    #    [AnnotatedMultiVCFFile, MultiVCFFile],
    #    AnnotatedMultiVCFFile,
    #    DefaultAttributesFrom(0),
    #    Constraint("backfilled", MUST_BE, "no", 0),
    #    Consequence("backfilled", SET_TO, "yes"),
    #    Constraint("vartype", MUST_BE, "consensus", 1),
    #    Constraint("caller", MUST_BE, "varscan", 1),
    #    ),

    ]
